enum IoError {
	OpenFailed,
	ReadFailed,
	WriteFailed,
	CloseFailed,
	AllocFailed,
}

enum IoReadResult {
	Ok(Bytes),
	Err(IoError),
}

enum IoWriteResult {
	Ok,
	Err(IoError),
}

namespace Io {
	fun initial_capacity() -> I32 {
		return 64
	}

	fun max_i32() -> I32 {
		return 2147483647
	}

	fun default_mode() -> PtrInt {
		return i32_to_i64(420)
	}

	fun write_flags_linux() -> Int {
		return 577
	}

	fun write_flags_darwin() -> Int {
		return 1537
	}

	fun open_read_only(path: String) -> Int {
		return Clib.open(String.ptr(path), 0, i32_to_i64(0))
	}

	fun open_write_truncate(path: String) -> Int {
		fd = Clib.open(String.ptr(path), Io.write_flags_linux(), Io.default_mode())
		if fd >= 0 {
			return fd
		}
		return Clib.open(String.ptr(path), Io.write_flags_darwin(), Io.default_mode())
	}

	fun grow_capacity(capacity: I32) -> I32 {
		if capacity < 1 {
			return 1
		}
		if capacity > 1073741823 {
			return Io.max_i32()
		}
		return capacity + capacity
	}

	fun read_all(fd: Int) -> IoReadResult {
		capacity = Io.initial_capacity()
		if capacity < 1 {
			capacity = 1
		}

		ptr = Clib.calloc(i32_to_i64(1), i32_to_i64(capacity))
		if ptr == i32_to_i64(0) {
			return IoReadResult.Err(IoError.AllocFailed)
		}

		len = 0
		while true {
			if len >= capacity {
				next_capacity = Io.grow_capacity(capacity)
				if next_capacity <= capacity {
					Clib.free(ptr)
					return IoReadResult.Err(IoError.AllocFailed)
				}
				next_ptr = Clib.realloc(ptr, i32_to_i64(next_capacity))
				if next_ptr == i32_to_i64(0) {
					Clib.free(ptr)
					return IoReadResult.Err(IoError.AllocFailed)
				}
				ptr = next_ptr
				capacity = next_capacity
			}

			out_ptr = ptr + i32_to_i64(len)
			nread = Clib.read(fd, out_ptr, i32_to_i64(1))
			if nread == i32_to_i64(1) {
				len = len + 1
			} else if nread == i32_to_i64(0) {
				bytes = Bytes struct {
					ptr: ptr,
					len: len,
				}
				return IoReadResult.Ok(bytes)
			} else {
				Clib.free(ptr)
				return IoReadResult.Err(IoError.ReadFailed)
			}
		}

		return IoReadResult.Err(IoError.ReadFailed)
	}

	fun write_all(fd: Int, data: Bytes) -> IoWriteResult {
		total = data.len
		if total < 0 {
			return IoWriteResult.Err(IoError.WriteFailed)
		}

		offset = 0
		while offset < total {
			chunk_ptr = data.ptr + i32_to_i64(offset)
			nwritten = Clib.write(fd, chunk_ptr, i32_to_i64(1))
			if nwritten == i32_to_i64(1) {
				offset = offset + 1
			} else {
				return IoWriteResult.Err(IoError.WriteFailed)
			}
		}

		return IoWriteResult.Ok
	}

	fun read_file(path: String) -> IoReadResult {
		fd = Io.open_read_only(path)
		if fd < 0 {
			return IoReadResult.Err(IoError.OpenFailed)
		}

		read_result = Io.read_all(fd)
		close_status = Clib.close(fd)
		match read_result {
			IoReadResult.Err(err) => {
				return IoReadResult.Err(err)
			}
			IoReadResult.Ok(bytes) => {
				if close_status != 0 {
					Clib.free(bytes.ptr)
					return IoReadResult.Err(IoError.CloseFailed)
				}
				return IoReadResult.Ok(bytes)
			}
		}
	}

	fun write_file(path: String, data: Bytes) -> IoWriteResult {
		fd = Io.open_write_truncate(path)
		if fd < 0 {
			return IoWriteResult.Err(IoError.OpenFailed)
		}

		write_result = Io.write_all(fd, data)
		close_status = Clib.close(fd)
		match write_result {
			IoWriteResult.Err(err) => {
				return IoWriteResult.Err(err)
			}
			IoWriteResult.Ok => {
				if close_status != 0 {
					return IoWriteResult.Err(IoError.CloseFailed)
				}
				return IoWriteResult.Ok
			}
		}
	}
}
