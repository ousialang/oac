generic LinkedList[T] {
	struct Node {
		len: I32,
		value: T,
		next: LinkedList,
	}

	enum LinkedList {
		Empty,
		Cons(Node),
	}

	enum FrontResult {
		Empty,
		Value(T),
	}

	enum TailResult {
		Empty,
		Value(LinkedList),
	}

	struct PopFrontValue {
		value: T,
		rest: LinkedList,
	}

	enum PopFrontResult {
		Empty,
		Value(PopFrontValue),
	}

	fun empty() -> LinkedList {
		return LinkedList.Empty
	}

	fun len(list: LinkedList) -> I32 {
		return match list {
			LinkedList.Empty => 0
			LinkedList.Cons(node) => node.len
		}
	}

	fun singleton(value: T) -> LinkedList {
		return push_front(value, empty())
	}

	fun cons(value: T, list: LinkedList) -> LinkedList {
		return push_front(value, list)
	}

	fun push_front(value: T, list: LinkedList) -> LinkedList {
		node = Node struct {
			len: len(list) + 1,
			value: value,
			next: list,
		}
		return LinkedList.Cons(node)
	}

	fun is_empty(list: LinkedList) -> Bool {
		return len(list) == 0
	}

	fun front(list: LinkedList) -> FrontResult {
		return match list {
			LinkedList.Empty => FrontResult.Empty
			LinkedList.Cons(node) => FrontResult.Value(node.value)
		}
	}

	fun tail(list: LinkedList) -> TailResult {
		return match list {
			LinkedList.Empty => TailResult.Empty
			LinkedList.Cons(node) => TailResult.Value(node.next)
		}
	}

	fun pop_front(list: LinkedList) -> PopFrontResult {
		match list {
			LinkedList.Empty => {
				return PopFrontResult.Empty
			}
			LinkedList.Cons(node) => {
				v = PopFrontValue struct {
					value: node.value,
					rest: node.next,
				}
				return PopFrontResult.Value(v)
			}
		}
	}

	fun head_or(list: LinkedList, fallback: T) -> T {
		return match front(list) {
			FrontResult.Empty => fallback
			FrontResult.Value(value) => value
		}
	}

	fun tail_or(list: LinkedList, fallback: LinkedList) -> LinkedList {
		return match tail(list) {
			TailResult.Empty => fallback
			TailResult.Value(next) => next
		}
	}

	fun length(list: LinkedList) -> I32 {
		return len(list)
	}

	fun reverse(list: LinkedList) -> LinkedList {
		cursor = list
		out = empty()
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return out
				}
				LinkedList.Cons(node) => {
					out = push_front(node.value, out)
					cursor = node.next
				}
			}
		}

		return out
	}

	fun append(left: LinkedList, right: LinkedList) -> LinkedList {
		cursor = reverse(left)
		out = right
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return out
				}
				LinkedList.Cons(node) => {
					out = push_front(node.value, out)
					cursor = node.next
				}
			}
		}

		return out
	}

	fun take(list: LinkedList, count: I32) -> LinkedList {
		if count <= 0 {
			return empty()
		}

		cursor = list
		remaining = count
		out_rev = empty()
		while remaining > 0 && !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return reverse(out_rev)
				}
				LinkedList.Cons(node) => {
					out_rev = push_front(node.value, out_rev)
					cursor = node.next
					remaining = remaining - 1
				}
			}
		}

		return reverse(out_rev)
	}

	fun drop(list: LinkedList, count: I32) -> LinkedList {
		if count <= 0 {
			return list
		}

		cursor = list
		remaining = count
		while remaining > 0 && !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return empty()
				}
				LinkedList.Cons(node) => {
					cursor = node.next
					remaining = remaining - 1
				}
			}
		}

		return cursor
	}

	fun at(list: LinkedList, index: I32) -> FrontResult {
		if index < 0 {
			return FrontResult.Empty
		}

		cursor = list
		i = 0
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return FrontResult.Empty
				}
				LinkedList.Cons(node) => {
					if i == index {
						return FrontResult.Value(node.value)
					}

					i = i + 1
					cursor = node.next
				}
			}
		}

		return FrontResult.Empty
	}

	fun at_or(list: LinkedList, index: I32, fallback: T) -> T {
		return match at(list, index) {
			FrontResult.Empty => fallback
			FrontResult.Value(value) => value
		}
	}
}

generic HashTable[K: Hash + Eq, V] {
	struct Entry {
		key: K,
		value: V,
	}

	struct EntryNode {
		entry: Entry,
		next: Bucket,
	}

	enum Bucket {
		Empty,
		Node(EntryNode),
	}

	struct BucketTreeNode {
		left: Buckets,
		right: Buckets,
	}

	enum Buckets {
		Leaf(Bucket),
		Branch(BucketTreeNode),
	}

	enum Lookup {
		Missing,
		Found(V),
	}

	struct HashTable {
		buckets: Buckets,
		bucket_count: I32,
		len: I32,
		resize_threshold: I32,
	}

	struct SetResult {
		table: HashTable,
		inserted_new: Bool,
	}

	struct RemoveResult {
		table: HashTable,
		removed: Lookup,
	}

	struct BucketSetResult {
		bucket: Bucket,
		inserted_new: Bool,
	}

	struct BucketRemoveResult {
		bucket: Bucket,
		removed: Lookup,
	}

	fun min_bucket_count() -> I32 {
		return 8
	}

	fun threshold_for_capacity(capacity: I32) -> I32 {
		threshold = (capacity * 3) / 4
		if threshold < 1 {
			return 1
		}
		return threshold
	}

	fun next_power_of_two(min_capacity: I32) -> I32 {
		n = HashTable.min_bucket_count()
		if min_capacity <= n {
			return n
		}

		while n < min_capacity {
			n = n + n
		}

		return n
	}

	fun empty_buckets(count: I32) -> Buckets {
		if count <= 1 {
			return Buckets.Leaf(Bucket.Empty)
		}

		half = count / 2
		left = HashTable.empty_buckets(half)
		right = HashTable.empty_buckets(half)
		node = BucketTreeNode struct {
			left: left,
			right: right,
		}
		return Buckets.Branch(node)
	}

	fun bucket_at(buckets: Buckets, count: I32, index: I32) -> Bucket {
		if count <= 1 {
			match buckets {
				Buckets.Leaf(bucket) => {
					return bucket
				}
				Buckets.Branch(node) => {
					return HashTable.bucket_at(node.left, 1, 0)
				}
			}
		}

		half = count / 2
		match buckets {
			Buckets.Leaf(bucket) => {
				return bucket
			}
			Buckets.Branch(node) => {
				if index < half {
					return HashTable.bucket_at(node.left, half, index)
				}
				return HashTable.bucket_at(node.right, half, index - half)
			}
		}
	}

	fun with_bucket(buckets: Buckets, count: I32, index: I32, bucket: Bucket) -> Buckets {
		if count <= 1 {
			return Buckets.Leaf(bucket)
		}

		half = count / 2
		match buckets {
			Buckets.Leaf(_old) => {
				return Buckets.Leaf(bucket)
			}
			Buckets.Branch(node) => {
				if index < half {
					left = HashTable.with_bucket(node.left, half, index, bucket)
					updated = BucketTreeNode struct {
						left: left,
						right: node.right,
					}
					return Buckets.Branch(updated)
				}
				right = HashTable.with_bucket(node.right, half, index - half, bucket)
				updated = BucketTreeNode struct {
					left: node.left,
					right: right,
				}
				return Buckets.Branch(updated)
			}
		}
	}

	fun modulo_non_negative(value: I32, divisor: I32) -> I32 {
		q = value / divisor
		r = value - (q * divisor)
		if r < 0 {
			return r + divisor
		}
		return r
	}

	fun hash_key(key: K) -> I32 {
		k = Hash.hash(key)
		if k < 0 {
			k = 0 - k
		}
		return k
	}

	fun bucket_index(key: K, bucket_count: I32) -> I32 {
		return HashTable.modulo_non_negative(HashTable.hash_key(key), bucket_count)
	}

	fun bucket_get(bucket: Bucket, key: K) -> Lookup {
		match bucket {
			Bucket.Empty => {
				return Lookup.Missing
			}
			Bucket.Node(node) => {
				entry = node.entry
				if Eq.equals(entry.key, key) {
					return Lookup.Found(entry.value)
				}
				return HashTable.bucket_get(node.next, key)
			}
		}
	}

	fun bucket_set(bucket: Bucket, key: K, value: V) -> BucketSetResult {
		match bucket {
			Bucket.Empty => {
				entry = Entry struct {
					key: key,
					value: value,
				}
				node = EntryNode struct {
					entry: entry,
					next: Bucket.Empty,
				}
				return BucketSetResult struct {
					bucket: Bucket.Node(node),
					inserted_new: true,
				}
			}
			Bucket.Node(node) => {
				entry = node.entry
				if Eq.equals(entry.key, key) {
					replaced_entry = Entry struct {
						key: key,
						value: value,
					}
					replaced_node = EntryNode struct {
						entry: replaced_entry,
						next: node.next,
					}
					return BucketSetResult struct {
						bucket: Bucket.Node(replaced_node),
						inserted_new: false,
					}
				}

				tail = HashTable.bucket_set(node.next, key, value)
				rebuilt = EntryNode struct {
					entry: entry,
					next: tail.bucket,
				}
				return BucketSetResult struct {
					bucket: Bucket.Node(rebuilt),
					inserted_new: tail.inserted_new,
				}
			}
		}
	}

	fun bucket_remove(bucket: Bucket, key: K) -> BucketRemoveResult {
		match bucket {
			Bucket.Empty => {
				return BucketRemoveResult struct {
					bucket: Bucket.Empty,
					removed: Lookup.Missing,
				}
			}
			Bucket.Node(node) => {
				entry = node.entry
				if Eq.equals(entry.key, key) {
					return BucketRemoveResult struct {
						bucket: node.next,
						removed: Lookup.Found(entry.value),
					}
				}

				tail = HashTable.bucket_remove(node.next, key)
				rebuilt = EntryNode struct {
					entry: entry,
					next: tail.bucket,
				}
				return BucketRemoveResult struct {
					bucket: Bucket.Node(rebuilt),
					removed: tail.removed,
				}
			}
		}
	}

	fun new() -> HashTable {
		return HashTable.with_capacity(HashTable.min_bucket_count())
	}

	fun with_capacity(min_capacity: I32) -> HashTable {
		cap = HashTable.next_power_of_two(min_capacity)
		buckets = HashTable.empty_buckets(cap)
		return HashTable struct {
			buckets: buckets,
			bucket_count: cap,
			len: 0,
			resize_threshold: HashTable.threshold_for_capacity(cap),
		}
	}

	fun set_no_resize(table: HashTable, key: K, value: V) -> SetResult {
		index = HashTable.bucket_index(key, table.bucket_count)
		bucket = HashTable.bucket_at(table.buckets, table.bucket_count, index)
		bucket_result = HashTable.bucket_set(bucket, key, value)
		next_buckets = HashTable.with_bucket(table.buckets, table.bucket_count, index, bucket_result.bucket)

		next_len = table.len
		if bucket_result.inserted_new {
			next_len = next_len + 1
		}

		next_table = HashTable struct {
			buckets: next_buckets,
			bucket_count: table.bucket_count,
			len: next_len,
			resize_threshold: table.resize_threshold,
		}
		return SetResult struct {
			table: next_table,
			inserted_new: bucket_result.inserted_new,
		}
	}

	fun insert_bucket_entries(dst: HashTable, bucket: Bucket) -> HashTable {
		match bucket {
			Bucket.Empty => {
				return dst
			}
			Bucket.Node(node) => {
				entry = node.entry
				set_result = HashTable.set_no_resize(dst, entry.key, entry.value)
				return HashTable.insert_bucket_entries(set_result.table, node.next)
			}
		}
	}

	fun insert_all_buckets(dst: HashTable, src: Buckets, count: I32) -> HashTable {
		if count <= 1 {
			match src {
				Buckets.Leaf(bucket) => {
					return HashTable.insert_bucket_entries(dst, bucket)
				}
				Buckets.Branch(node) => {
					left = HashTable.insert_all_buckets(dst, node.left, 1)
					return HashTable.insert_all_buckets(left, node.right, 1)
				}
			}
		}

		half = count / 2
		match src {
			Buckets.Leaf(bucket) => {
				return HashTable.insert_bucket_entries(dst, bucket)
			}
			Buckets.Branch(node) => {
				left = HashTable.insert_all_buckets(dst, node.left, half)
				return HashTable.insert_all_buckets(left, node.right, half)
			}
		}
	}

	fun rehash(table: HashTable, new_bucket_count: I32) -> HashTable {
		cap = HashTable.next_power_of_two(new_bucket_count)
		fresh = HashTable.with_capacity(cap)
		return HashTable.insert_all_buckets(fresh, table.buckets, table.bucket_count)
	}

	fun maybe_resize_before_insert(table: HashTable) -> HashTable {
		if table.len + 1 > table.resize_threshold {
			return HashTable.rehash(table, table.bucket_count + table.bucket_count)
		}
		return table
	}

	fun set(table: HashTable, key: K, value: V) -> SetResult {
		resized = HashTable.maybe_resize_before_insert(table)
		return HashTable.set_no_resize(resized, key, value)
	}

	fun get(table: HashTable, key: K) -> Lookup {
		index = HashTable.bucket_index(key, table.bucket_count)
		bucket = HashTable.bucket_at(table.buckets, table.bucket_count, index)
		return HashTable.bucket_get(bucket, key)
	}

	fun remove(table: HashTable, key: K) -> RemoveResult {
		index = HashTable.bucket_index(key, table.bucket_count)
		bucket = HashTable.bucket_at(table.buckets, table.bucket_count, index)
		bucket_result = HashTable.bucket_remove(bucket, key)
		next_buckets = HashTable.with_bucket(table.buckets, table.bucket_count, index, bucket_result.bucket)

		next_len = table.len
		match bucket_result.removed {
			Lookup.Missing => {
			}
			Lookup.Found(_value) => {
				next_len = next_len - 1
			}
		}

		next_table = HashTable struct {
			buckets: next_buckets,
			bucket_count: table.bucket_count,
			len: next_len,
			resize_threshold: table.resize_threshold,
		}
		return RemoveResult struct {
			table: next_table,
			removed: bucket_result.removed,
		}
	}

	fun clear(table: HashTable) -> HashTable {
		buckets = HashTable.empty_buckets(table.bucket_count)
		return HashTable struct {
			buckets: buckets,
			bucket_count: table.bucket_count,
			len: 0,
			resize_threshold: table.resize_threshold,
		}
	}

	fun contains_key(table: HashTable, key: K) -> Bool {
		return match HashTable.get(table, key) {
			Lookup.Missing => false
			Lookup.Found(_value) => true
		}
	}

	fun len(table: HashTable) -> I32 {
		return table.len
	}

	fun capacity(table: HashTable) -> I32 {
		return table.bucket_count
	}
}

test "A hashtable MUST have len 0 when created" {
	table = HashTable.new()
	assert(HashTable.len(table) == 0)
}

test "A hashtable insert/get MUST work" {
	r = HashTable.set(HashTable.new(), 10, 99)
	table = r.table
	assert(r.inserted_new)
	assert(HashTable.len(table) == 1)
	match HashTable.get(table, 10) {
		HashTable__Lookup.Missing => {
			assert(false)
		}
		HashTable__Lookup.Found(v) => {
			assert(v == 99)
		}
	}
}

test "A hashtable update MUST not increase len" {
	r1 = HashTable.set(HashTable.new(), 1, 10)
	r2 = HashTable.set(r1.table, 1, 11)
	if r2.inserted_new {
		assert(false)
	}
	assert(HashTable.len(r2.table) == 1)
	match HashTable.get(r2.table, 1) {
		HashTable__Lookup.Missing => {
			assert(false)
		}
		HashTable__Lookup.Found(v) => {
			assert(v == 11)
		}
	}
}

test "A hashtable remove MUST decrease len" {
	r1 = HashTable.set(HashTable.new(), 1, 10)
	r2 = HashTable.set(r1.table, 9, 90)
	removed = HashTable.remove(r2.table, 9)
	assert(HashTable.len(removed.table) == 1)
	match removed.removed {
		HashTable__Lookup.Missing => {
			assert(false)
		}
		HashTable__Lookup.Found(v) => {
			assert(v == 90)
		}
	}
}

test "A hashtable resize MUST preserve entries" {
	table = HashTable.new()
	i = 0
	while i < 20 {
		r = HashTable.set(table, 100 + i, i)
		table = r.table
		i = i + 1
	}
	assert(HashTable.len(table) == 20)
	assert(HashTable.capacity(table) >= 20)
	match HashTable.get(table, 100) {
		HashTable__Lookup.Missing => {
			assert(false)
		}
		HashTable__Lookup.Found(v) => {
			assert(v == 0)
		}
	}
	match HashTable.get(table, 119) {
		HashTable__Lookup.Missing => {
			assert(false)
		}
		HashTable__Lookup.Found(v) => {
			assert(v == 19)
		}
	}
}
