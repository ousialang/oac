struct Bytes {
	ptr: PtrInt,
	len: I32,
}

invariant non_negative_length "bytes length must be non-negative" for (v: Bytes) {
	return v.len >= 0
}

enum String {
	Literal(Bytes),
	Heap(Bytes),
}

namespace String {
	fun make_bytes(ptr: PtrInt, len: I32) -> Bytes {
		safe_len = len
		if safe_len < 0 {
			safe_len = 0
		}

		return Bytes struct {
			ptr: ptr,
			len: safe_len,
		}
	}

	fun bytes(s: String) -> Bytes {
		return match s {
			String.Literal(b) => String.make_bytes(b.ptr, b.len)
			String.Heap(b) => String.make_bytes(b.ptr, b.len)
		}
	}

	fun ptr(s: String) -> PtrInt {
		b = String.bytes(s)
		return b.ptr
	}

	fun len(s: String) -> I32 {
		b = String.bytes(s)
		return b.len
	}

	fun is_empty(s: String) -> Bool {
		return String.len(s) == 0
	}

	fun equals(a: String, b: String) -> Bool {
		len_a = String.len(a)
		len_b = String.len(b)
		if len_a != len_b {
			return false
		}

		i = 0
		while i < len_a {
			if char_at(a, i) != char_at(b, i) {
				return false
			}
			i = i + 1
		}

		return true
	}

	fun starts_with(s: String, prefix: String) -> Bool {
		n = String.len(s)
		m = String.len(prefix)
		if m > n {
			return false
		}

		i = 0
		while i < m {
			if char_at(s, i) != char_at(prefix, i) {
				return false
			}
			i = i + 1
		}

		return true
	}

	fun ends_with(s: String, suffix: String) -> Bool {
		n = String.len(s)
		m = String.len(suffix)
		if m > n {
			return false
		}

		offset = n - m
		i = 0
		while i < m {
			if char_at(s, offset + i) != char_at(suffix, i) {
				return false
			}
			i = i + 1
		}

		return true
	}

	fun char_at_or(s: String, index: I32, fallback: I32) -> I32 {
		n = String.len(s)
		if index < 0 || index >= n {
			return fallback
		}
		return char_at(s, index)
	}

	fun slice_clamped(s: String, start: I32, len: I32) -> String {
		n = String.len(s)
		safe_start = start
		if safe_start < 0 {
			safe_start = 0
		}
		if safe_start > n {
			safe_start = n
		}

		safe_len = len
		if safe_len < 0 {
			safe_len = 0
		}
		max_len = n - safe_start
		if safe_len > max_len {
			safe_len = max_len
		}

		return slice(s, safe_start, safe_len)
	}

	fun from_literal_parts(ptr: PtrInt, len: I32) -> String {
		b = String.make_bytes(ptr, len)
		return String.Literal(b)
	}

	fun from_heap_parts(ptr: PtrInt, len: I32) -> String {
		b = String.make_bytes(ptr, len)
		return String.Heap(b)
	}
}
