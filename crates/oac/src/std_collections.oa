template LinkedList[T] {
	struct Node {
		len: I32,
		value: T,
		next: LinkedList,
	}

	enum LinkedList {
		Empty,
		Cons(Node),
	}

	enum FrontResult {
		Empty,
		Value(T),
	}

	enum TailResult {
		Empty,
		Value(LinkedList),
	}

	struct PopFrontValue {
		value: T,
		rest: LinkedList,
	}

	enum PopFrontResult {
		Empty,
		Value(PopFrontValue),
	}

	fun empty() -> LinkedList {
		return LinkedList.Empty
	}

	fun len(list: LinkedList) -> I32 {
		return match list {
			LinkedList.Empty => 0
			LinkedList.Cons(node) => node.len
		}
	}

	fun singleton(value: T) -> LinkedList {
		return push_front(value, empty())
	}

	fun cons(value: T, list: LinkedList) -> LinkedList {
		return push_front(value, list)
	}

	fun push_front(value: T, list: LinkedList) -> LinkedList {
		node = Node struct {
			len: len(list) + 1,
			value: value,
			next: list,
		}
		return LinkedList.Cons(node)
	}

	fun is_empty(list: LinkedList) -> Bool {
		return len(list) == 0
	}

	fun front(list: LinkedList) -> FrontResult {
		return match list {
			LinkedList.Empty => FrontResult.Empty
			LinkedList.Cons(node) => FrontResult.Value(node.value)
		}
	}

	fun tail(list: LinkedList) -> TailResult {
		return match list {
			LinkedList.Empty => TailResult.Empty
			LinkedList.Cons(node) => TailResult.Value(node.next)
		}
	}

	fun pop_front(list: LinkedList) -> PopFrontResult {
		match list {
			LinkedList.Empty => {
				return PopFrontResult.Empty
			}
			LinkedList.Cons(node) => {
				v = PopFrontValue struct {
					value: node.value,
					rest: node.next,
				}
				return PopFrontResult.Value(v)
			}
		}
	}

	fun head_or(list: LinkedList, fallback: T) -> T {
		return match front(list) {
			FrontResult.Empty => fallback
			FrontResult.Value(value) => value
		}
	}

	fun tail_or(list: LinkedList, fallback: LinkedList) -> LinkedList {
		return match tail(list) {
			TailResult.Empty => fallback
			TailResult.Value(next) => next
		}
	}

	fun length(list: LinkedList) -> I32 {
		return len(list)
	}

	fun reverse(list: LinkedList) -> LinkedList {
		cursor = list
		out = empty()
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return out
				}
				LinkedList.Cons(node) => {
					out = push_front(node.value, out)
					cursor = node.next
				}
			}
		}

		return out
	}

	fun append(left: LinkedList, right: LinkedList) -> LinkedList {
		cursor = reverse(left)
		out = right
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return out
				}
				LinkedList.Cons(node) => {
					out = push_front(node.value, out)
					cursor = node.next
				}
			}
		}

		return out
	}

	fun take(list: LinkedList, count: I32) -> LinkedList {
		if count <= 0 {
			return empty()
		}

		cursor = list
		remaining = count
		out_rev = empty()
		while remaining > 0 && !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return reverse(out_rev)
				}
				LinkedList.Cons(node) => {
					out_rev = push_front(node.value, out_rev)
					cursor = node.next
					remaining = remaining - 1
				}
			}
		}

		return reverse(out_rev)
	}

	fun drop(list: LinkedList, count: I32) -> LinkedList {
		if count <= 0 {
			return list
		}

		cursor = list
		remaining = count
		while remaining > 0 && !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return empty()
				}
				LinkedList.Cons(node) => {
					cursor = node.next
					remaining = remaining - 1
				}
			}
		}

		return cursor
	}

	fun at(list: LinkedList, index: I32) -> FrontResult {
		if index < 0 {
			return FrontResult.Empty
		}

		cursor = list
		i = 0
		while !is_empty(cursor) {
			match cursor {
				LinkedList.Empty => {
					return FrontResult.Empty
				}
				LinkedList.Cons(node) => {
					if i == index {
						return FrontResult.Value(node.value)
					}

					i = i + 1
					cursor = node.next
				}
			}
		}

		return FrontResult.Empty
	}

	fun at_or(list: LinkedList, index: I32, fallback: T) -> T {
		return match at(list, index) {
			FrontResult.Empty => fallback
			FrontResult.Value(value) => value
		}
	}
}

template HashTable[T] {
	struct Entry {
		key: I32,
		value: T,
	}

	enum Slot {
		Empty,
		Node(Entry),
	}

	enum Lookup {
		Missing,
		Found(T),
	}

	struct HashTable {
		s0: Slot,
		s1: Slot,
		s2: Slot,
		s3: Slot,
		s4: Slot,
		s5: Slot,
		s6: Slot,
		s7: Slot,
	}

	fun empty() -> HashTable {
		return HashTable struct { s0: Slot.Empty, s1: Slot.Empty, s2: Slot.Empty, s3: Slot.Empty, s4: Slot.Empty, s5: Slot.Empty, s6: Slot.Empty, s7: Slot.Empty, }
	}

	fun hash_key(key: I32) -> I32 {
		k = key
		if k < 0 {
			k = 0 - k
		}

		div = k / 8
		return k - (div * 8)
	}

	fun slot_at(table: HashTable, index: I32) -> Slot {
		if index == 0 {
			return table.s0
		}
		if index == 1 {
			return table.s1
		}
		if index == 2 {
			return table.s2
		}
		if index == 3 {
			return table.s3
		}
		if index == 4 {
			return table.s4
		}
		if index == 5 {
			return table.s5
		}
		if index == 6 {
			return table.s6
		}

		return table.s7
	}

	fun with_slot(table: HashTable, index: I32, slot: Slot) -> HashTable {
		if index == 0 {
			return HashTable struct { s0: slot, s1: table.s1, s2: table.s2, s3: table.s3, s4: table.s4, s5: table.s5, s6: table.s6, s7: table.s7, }
		}
		if index == 1 {
			return HashTable struct { s0: table.s0, s1: slot, s2: table.s2, s3: table.s3, s4: table.s4, s5: table.s5, s6: table.s6, s7: table.s7, }
		}
		if index == 2 {
			return HashTable struct { s0: table.s0, s1: table.s1, s2: slot, s3: table.s3, s4: table.s4, s5: table.s5, s6: table.s6, s7: table.s7, }
		}
		if index == 3 {
			return HashTable struct { s0: table.s0, s1: table.s1, s2: table.s2, s3: slot, s4: table.s4, s5: table.s5, s6: table.s6, s7: table.s7, }
		}
		if index == 4 {
			return HashTable struct { s0: table.s0, s1: table.s1, s2: table.s2, s3: table.s3, s4: slot, s5: table.s5, s6: table.s6, s7: table.s7, }
		}
		if index == 5 {
			return HashTable struct { s0: table.s0, s1: table.s1, s2: table.s2, s3: table.s3, s4: table.s4, s5: slot, s6: table.s6, s7: table.s7, }
		}
		if index == 6 {
			return HashTable struct { s0: table.s0, s1: table.s1, s2: table.s2, s3: table.s3, s4: table.s4, s5: table.s5, s6: slot, s7: table.s7, }
		}

		return HashTable struct { s0: table.s0, s1: table.s1, s2: table.s2, s3: table.s3, s4: table.s4, s5: table.s5, s6: table.s6, s7: slot, }
	}

	fun add_wrap(index: I32, delta: I32) -> I32 {
		n = index + delta
		if n >= 8 {
			return n - 8
		}
		return n
	}

	fun put_probe(table: HashTable, start: I32, delta: I32, key: I32, value: T) -> HashTable {
		if delta >= 8 {
			return table
		}

		index = add_wrap(start, delta)
		slot = slot_at(table, index)
		match slot {
			Slot.Empty => {
				entry = Entry struct { key: key, value: value, }
				return with_slot(table, index, Slot.Node(entry))
			}
			Slot.Node(entry) => {
				if entry.key == key {
					replaced = Entry struct { key: key, value: value, }
					return with_slot(table, index, Slot.Node(replaced))
				}
				return put_probe(table, start, delta + 1, key, value)
			}
		}
	}

	fun get_probe(table: HashTable, start: I32, delta: I32, key: I32) -> Lookup {
		if delta >= 8 {
			return Lookup.Missing
		}

		index = add_wrap(start, delta)
		slot = slot_at(table, index)
		match slot {
			Slot.Empty => {
				return Lookup.Missing
			}
			Slot.Node(entry) => {
				if entry.key == key {
					return Lookup.Found(entry.value)
				}
				return get_probe(table, start, delta + 1, key)
			}
		}
	}

	fun slot_size(slot: Slot) -> I32 {
		return match slot {
			Slot.Empty => 0
			Slot.Node(_entry) => 1
		}
	}

	fun put(table: HashTable, key: I32, value: T) -> HashTable {
		start = hash_key(key)
		return put_probe(table, start, 0, key, value)
	}

	fun get(table: HashTable, key: I32) -> Lookup {
		start = hash_key(key)
		return get_probe(table, start, 0, key)
	}

	fun contains_key(table: HashTable, key: I32) -> Bool {
		return match get(table, key) {
			Lookup.Missing => false
			Lookup.Found(_value) => true
		}
	}

	fun size(table: HashTable) -> I32 {
		return slot_size(table.s0) + slot_size(table.s1) + slot_size(table.s2) + slot_size(table.s3) + slot_size(table.s4) + slot_size(table.s5) + slot_size(table.s6) + slot_size(table.s7)
	}
}

test "A hashtable MUST have size 0 when created" {
	table = HashTable.empty()
	assert(HashTable.size(table) == 0)
}
